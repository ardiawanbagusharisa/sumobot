// # This implementation is generated by ChatGPT. 
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace PacingFramework
{
	public class PacingController : MonoBehaviour
	{
		// ================================
		// Runtime Config
		// ================================
		public float segmentDuration = 5f;
		private float timer;

		private SegmentGameplayData currentGameplayData;
		private SegmentPacing currentSegmentPacing;

		public GamePacing pacingHistory = new GamePacing();
		public GamePacingTarget pacingTarget = new GamePacingTarget();

		// ================================
		// Unity
		// ================================
		private void Start() {
			Init();
			TestSimulation(); // Auto test
		}

		private void Update() {
			TestSimulateRuntimeData();
			Tick(Time.deltaTime);
		}

		// ================================
		// Core Methods
		// ================================
		public void Init() {
			currentGameplayData = new SegmentGameplayData();
			timer = 0f;
		}

		public void Tick(float deltaTime) {
			timer += deltaTime;

			if (timer >= segmentDuration) {
				FinalizeSegment();
				timer = 0f;
				currentGameplayData.Reset();
			}
		}

		private void FinalizeSegment() {
			currentSegmentPacing = new SegmentPacing(currentGameplayData, pacingTarget.GlobalConstraints);

			pacingHistory.SegmentGameplayDatas.Add(new SegmentGameplayData(currentGameplayData));
			pacingHistory.SegmentPacings.Add(currentSegmentPacing);

			DebugPacing(currentSegmentPacing);
		}

		private void DebugPacing(SegmentPacing pacing) {
			Debug.Log("===== SEGMENT FINALIZED =====");
			Debug.Log("Threat: " + pacing.ThreatAspect.Value);
			Debug.Log("Tempo: " + pacing.TempoAspect.Value);
			Debug.Log("Overall: " + pacing.GetOverallPacing());
		}

		// ================================
		// TEST FUNCTION
		// ================================
		public void TestSimulation() {
			Debug.Log("Running Pacing Test Simulation...");

			for (int i = 0; i < 20; i++) {
				currentGameplayData.RegisterCollision(CollisionType.Hit);
				currentGameplayData.RegisterAngle(UnityEngine.Random.Range(0f, 180f));
				currentGameplayData.RegisterSafeDistance(UnityEngine.Random.Range(1f, 10f));
				currentGameplayData.RegisterVelocity(UnityEngine.Random.Range(0f, 5f));
				currentGameplayData.RegisterBotsDistance(UnityEngine.Random.Range(1f, 15f));

				currentGameplayData.RegisterAction(
					(ActionType)UnityEngine.Random.Range(0, Enum.GetValues(typeof(ActionType)).Length)
				);
			}

			FinalizeSegment();
		}

		private void TestSimulateRuntimeData() {
			currentGameplayData.RegisterCollision(CollisionType.Hit);
			currentGameplayData.RegisterAngle(UnityEngine.Random.Range(0f, 180f));
			currentGameplayData.RegisterSafeDistance(UnityEngine.Random.Range(1f, 10f));
			currentGameplayData.RegisterVelocity(UnityEngine.Random.Range(0f, 5f));
			currentGameplayData.RegisterBotsDistance(UnityEngine.Random.Range(1f, 15f));

			currentGameplayData.RegisterAction(
				(ActionType)UnityEngine.Random.Range(0, Enum.GetValues(typeof(ActionType)).Length)
			);
		}

	}

	// ==========================================================
	// DATA CONTAINERS
	// ==========================================================

	public class GamePacing
	{
		public List<SegmentGameplayData> SegmentGameplayDatas = new();
		public List<SegmentPacing> SegmentPacings = new();
	}

	public class GamePacingTarget
	{
		public ConstraintsSet GlobalConstraints = new ConstraintsSet();
	}

	// ==========================================================
	// ENUMS
	// ==========================================================

	public enum AspectType { Threat, Tempo }
	public enum CollisionType { Hit, Struck, Tie }
	public enum ActionType { Accelerate, TurnLeft, TurnRight, Dash, SkillBoost, SkillStone, Idle }

	// ==========================================================
	// CONSTRAINT
	// ==========================================================

	public class Constraint
	{
		public float Min;
		public float Max;

		public Constraint(float min, float max) {
			Min = min;
			Max = max;
		}

		public float Normalize(float value) {
			if (Mathf.Approximately(Max, Min)) return 0f;
			return Mathf.Clamp01((value - Min) / (Max - Min));
		}
	}

	public class ConstraintsSet
	{
		public Constraint Collision = new(0, 10);
		public Constraint Angle = new(0, 180);
		public Constraint SafeDistance = new(0, 20);
		public Constraint DashSkill = new(0, 10);

		public Constraint ActionIntensity = new(0, 20);
		public Constraint ActionDensity = new(0, 3);
		public Constraint BotsDistance = new(0, 20);
		public Constraint Velocity = new(0, 10);
	}

	// ==========================================================
	// SEGMENT GAMEPLAY DATA
	// ==========================================================

	public class SegmentGameplayData
	{
		public List<CollisionType> Collisions = new();
		public List<float> Angles = new();
		public List<float> SafeDistances = new();
		public List<ActionType> Actions = new();
		public List<float> BotsDistances = new();
		public List<float> Velocities = new();

		public SegmentGameplayData() { }

		public SegmentGameplayData(SegmentGameplayData other) {
			Collisions = new(other.Collisions);
			Angles = new(other.Angles);
			SafeDistances = new(other.SafeDistances);
			Actions = new(other.Actions);
			BotsDistances = new(other.BotsDistances);
			Velocities = new(other.Velocities);
		}

		public void Reset() {
			Collisions.Clear();
			Angles.Clear();
			SafeDistances.Clear();
			Actions.Clear();
			BotsDistances.Clear();
			Velocities.Clear();
		}

		public void RegisterCollision(CollisionType type) => Collisions.Add(type);
		public void RegisterAngle(float angle) => Angles.Add(angle);
		public void RegisterSafeDistance(float d) => SafeDistances.Add(d);
		public void RegisterAction(ActionType action) => Actions.Add(action);
		public void RegisterBotsDistance(float d) => BotsDistances.Add(d);
		public void RegisterVelocity(float v) => Velocities.Add(v);

		public Dictionary<ActionType, int> GetActionCounts() {
			return Actions.GroupBy(a => a)
						  .ToDictionary(g => g.Key, g => g.Count());
		}
	}

	// ==========================================================
	// SEGMENT PACING
	// ==========================================================

	public class SegmentPacing
	{
		public Threat ThreatAspect;
		public Tempo TempoAspect;

		public SegmentPacing(SegmentGameplayData data, ConstraintsSet constraints) {
			ThreatAspect = new Threat(data, constraints);
			TempoAspect = new Tempo(data, constraints);
		}

		public float GetOverallPacing() {
			return (ThreatAspect.Value + TempoAspect.Value) / 2f;
		}
	}

	// ==========================================================
	// ASPECT BASE
	// ==========================================================

	public abstract class Aspect
	{
		protected SegmentGameplayData data;
		protected ConstraintsSet constraints;

		public float Value { get; protected set; }

		public Aspect(SegmentGameplayData data, ConstraintsSet constraints) {
			this.data = data;
			this.constraints = constraints;
			Calculate();
		}

		protected abstract void Calculate();
	}

	// ==========================================================
	// THREAT
	// ==========================================================

	public class Threat : Aspect
	{
		public Threat(SegmentGameplayData data, ConstraintsSet constraints)
			: base(data, constraints) { }

		protected override void Calculate() {
			float collision = constraints.Collision.Normalize(data.Collisions.Count);
			float dash = constraints.DashSkill.Normalize(
				data.Actions.Count(a => a == ActionType.Dash || a == ActionType.SkillBoost)
			);

			float angle = data.Angles.Count > 0
				? constraints.Angle.Normalize(data.Angles.Average())
				: 0f;

			float safeDistance = data.SafeDistances.Count > 0
				? 1f - constraints.SafeDistance.Normalize(data.SafeDistances.Average())
				: 0f;

			Value = (collision + dash + angle + safeDistance) / 4f;
		}
	}

	// ==========================================================
	// TEMPO
	// ==========================================================

	public class Tempo : Aspect
	{
		public Tempo(SegmentGameplayData data, ConstraintsSet constraints)
			: base(data, constraints) { }

		protected override void Calculate() {
			float actionIntensity = constraints.ActionIntensity.Normalize(data.Actions.Count);

			float actionDensity = 0f;
			if (data.Actions.Count > 0) {
				var counts = data.GetActionCounts();
				float total = data.Actions.Count;
				float entropy = 0f;

				foreach (var c in counts.Values) {
					float p = c / total;
					entropy -= p * Mathf.Log(p);
				}

				actionDensity = constraints.ActionDensity.Normalize(entropy);
			}

			float botDistance = data.BotsDistances.Count > 0
				? 1f - constraints.BotsDistance.Normalize(data.BotsDistances.Average())
				: 0f;

			float velocity = data.Velocities.Count > 0
				? constraints.Velocity.Normalize(data.Velocities.Average())
				: 0f;

			Value = (actionIntensity + actionDensity + botDistance + velocity) / 4f;
		}
	}
}

// # Our original intention. 

//using UnityEngine;

//namespace PacingFramework 
//{
//	public class PacingController : MonoBehaviour
//	{
//		// Fields ==========
//		//Pacing History: GamePacing
//		//Pacing Target: GamePacingTarget

//		// Runtime Configs ==========
//		//SegmentDuration: float  
//		//API: SumoAPI
//		//Original Actions: <SumoAction> 
//		//Paced Actions: <SumoAction> 

//		// Temporary holder ==========
//		//Current Gameplay Data: SegmentGameplayData
//		//Current Segment Pacing: SegmentPacing

//		// Methods ==========
//		//Init(): void // Initialize all fields
//		//Register functions of GameplayData -> few Register functions to register the raw data into currentGameplayData.

//		//Tick(): void // Act like update for each game tick to allow register functions calling on currentGameplayData.
//		//If a segment is reached, finalize the segment by populating the variables in segmentgameplaydata, compute pacing factors, and compute pacing aspect using finalize segment methods.
//		//Then debug/ visualize it using debugpacing().
//		//Later on we can also evaluate the pacing and actions using evaluation methods. 

//		// Finalize Segment Methods ==========
//		//PopulateSegmentGameplayData(): void // After currentSegmentData is registered and a segment is reached, ready for factor calculations. 
//		//ComputeFactors(): void // Compute the pacing factors in currentsegmentpacing.Factors. Here, we need constraints for normalization and some helper functions from constraints: blending between global and local, or for each bot. 
//		//ComputePacingAspect(): void // Compute the pacing aspect threat and tempo in currentsegmentpacing.Aspects and add data into pacinghistory.segmentgameplaydata and pacinghistory.pacing. 
//		//DebugPacing(): void // Debug or visualize to console the details of pacing and segmentgameplaydata. 

//		// Evaluation methods =========
//		//EvaluatePacing(): void // Compare the actual latest pacing in pacinghistory with the pacingtarget according to the index. 
//		//EvaluateAction(): void // Filtered out the original actions into paced actions. This requires rules on how to filter the action based on the pacing values. 

//	}

//	// ========================================== 
//	public struct GamePacing 
//	{
//		// Fields ==========
//		//List of Segment GameplayData: <SegmentGameplayData> 
//		//List of Segment Pacing: <SegmentPacing> 
//		//Curve of Pacing: PacingCurve // Custom curve for visualization 
//	}

//	public struct GamePacingTarget 
//	{
//		// Fields ==========
//		//Global Constraints: Constraints 
//		//List of Local Constraints: <Constraints>  
//		//List of Target Pacing: <Segment Pacing>
//		//Curve of Pacing: PacingCurve // Custom curve for visualization 
//	}

//	// ====================================================================================
//	// Pacing.cs
//	// ====================================================================================
//	public enum AspectType
//	{
//		Threat,
//		Tempo
//	}

//	public enum CollisionType
//	{
//		Hit,
//		Struck,
//		Tie
//	}

//	public enum ActionType
//	{
//		Accelerate,
//		TurnLeft,
//		TurnRight,
//		Dash,
//		SkillBoost,
//		SkillStone,
//		Idle
//	}

//	public enum FactorType
//	{
//		// Threat factors
//		HitCollision,
//		Ability,
//		Angle,
//		SafeDistance,

//		//Tempo factors
//		ActionIntensity,
//		ActionDensity,
//		BotsDistance,
//		Velocity
//	}

//	public class Constraint { 
//		// Fields ==========
//		//Min: float
//		//Max: float

//		// Methods =========
//		//Constructor(min, max) 
//		//IsInRange(value): bool // return if the value is in constraint range. 
//	}

//	public struct ConstraintsSet {
//		// Fields ==========
//		//Threat fields
//		//AvgHitCollision: constraint // factor avghitcollision: return 1 if hitcollision closer to max, return 0 if closer to min
//		//AvgAngle: constraint // factor avgangle: return 1 if closer to min, return 0 if closer to max 
//		//AvgSafeDistance: constraint // factor avgsafedistance: return 1 if closer to max, return 0 if closer to min 
//		//AvgDashSkill: constraint // factor avgdashskill: return 1 if skill count closer to max, return 0 if closer to min 

//		//Tempo fields
//		//AvgAction: constraint // factor acvaction: return 1 if closer to max, return 0 if closer to min 
//		//AvgBotDistance: constraint // factor avgbotdistance: return 1 if closer to min, return 0 if closer to max
//		//AvgVelocity: constraint // factor avgvelocity: return 1 if closer to max, return 0 if closer to min 
//		//AvgActionDensity: constraint // factor avgactiondensity: return 1 if closer to max, retunr 0 if closer to min; use shannon entropy

//		// Methods ==========
//		//NormalizedClamped(value, constraint): float // return the normalized and clamped value using this constraint. 
//		//GetConstraintsByType(aspect type): dict<string, constraints> // return dictionary of constraint based on its aspect type related. 
//	}

//	public class SegmentGameplayData {
//		// Fields ==========
//		//Threat fields
//		//List of collisions: <CollisionType>
//		//List of agent angles: <float>
//		//List of safe distances: <float> 

//		//Tempo fields
//		//List of list of actions: <<actiontype>> // This will be used in factor of action and action variation. 
//		//List of bots distances: <float>
//		//List of agent velocities: <float>

//		// Methods ==========
//		//Constructor()
//		//Constructor(SegmentGameplayData)
//		//Reset()

//		// Register methods 
//		//RegisterCollision(bounceevent or collisiontype, api): void 
//		//RegisterAngle(api): void
//		//RegisterSafeDistance(api): void 
//		//RegisterActions(<actiontype> or api): void // Register list of actions from api 
//		//RegisterBotsDistance(api): void

//		// Helper methods 
//		//GetCollisionsCounts(): dict<collisiontype, int>
//		//GetActionsCounts(): dict<actiontype, int>
//		//SafeDistance(pos, battleinfo): float
//	}

//	public class SegmentPacing 
//	{
//		// Fields ==========
//		//Threat aspect: Aspect 
//		//Tempo aspect: Aspect 
//		//Constraints: Constraintsset [optional]

//		// Methods ==========
//		//GetOverallPacing(): float
//	}

//	public abstract class Aspect {
//		// Fields ==========
//		//Type: AspectType
//		//Weight: float 
//		//Value: float getter; call CalculatePacingAspect()

//		// Private fields
//		//GameplayData: SegmentGameplayData
//		//Constraints: Constraintsset [optional]

//		// Methods ==========	
//		//Constructor(SegmentGameplayData) 
//		//CalculateAspect(): float // Requires function calling from factors 
//		//Reset(): void 

//		// Helper methods
//		//GetWeightByType(factor type): float
//	}

//	public class Threat : Aspect {
//		// Additional Fields ==========
//		//ThreatFactors

//		// Additional Methods ==========	
//	}
//	public class Tempo : Aspect {
//		// Additional Fields ==========
//		//TempoFactors

//		// Additional Methods ==========
//	}

//	// Option 1 implementation of factors
//	public struct ThreatFactors
//	{
//		// Fields ==========
//		//Collision: float getter // Call EvaluateCollision()
//		//DashSkill: float getter // Call EvaluateDashSkill()
//		//Angle: float getter // Call EvaluateAngle()
//		//SafeDistance: float getter // Call EvaluateSafeDistance()

//		//Weight Collision: float 
//		//Weight DashSkill: float 
//		//Weight Angle: float 
//		//Weight SafeDistance: float
//		//TotalWeights: float getter // return sum of all weights. 

//		// Methods ==========
//		//Constructor(weights)
//		//EvaluateCollision(segmentdata, constraint): float  // Not necessary to make segmentdata and constraint as fields.
//		//EvaluateDashSkill(segmentdata, constraint): float 
//		//EvaluateAngle(segmentdata, constraint): float 
//		//EvaluateSafeDistance(segmentdata, constraint): float 
//	}

//	public struct TempoFactors 
//	{
//		// Fields ==========
//		//ActionIntensity: float getter
//		//ActionDensity: float getter 
//		//BotsDistance: float getter 
//		//Velocity: float getter

//		//Weight ActionIntensity: float 
//		//Weight ActionDensity: float 
//		//Weight BotsDistance: float 
//		//Weight Velocity: float

//		// Methods ==========
//		//Constructor(weights)
//		//EvaluateActionIntensity(segmentdata, constraint): float // Not necessary to make segmentdata and constraint as fields. 
//		//EvaluateActionDensity(segmentdata, constraint): float
//		//EvaluateBotDistance(segmentdata, constraint): float
//		//EvaluateVelocity(segmentdata, constraint): float
//	}
//}

